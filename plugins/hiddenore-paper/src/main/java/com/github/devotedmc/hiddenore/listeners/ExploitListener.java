package com.github.devotedmc.hiddenore.listeners;

import java.util.logging.Level;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.EntityType;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockExplodeEvent;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockPistonRetractEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityChangeBlockEvent;

import com.github.devotedmc.hiddenore.Config;
import com.github.devotedmc.hiddenore.HiddenOre;

/**
 * Moving exploit tracking here for easier expansion / searching. 
 * 
 * @author ProgrammerDan
 */
public class ExploitListener implements Listener {
	private final HiddenOre plugin;
	
	public ExploitListener(HiddenOre plugin) {
		this.plugin = plugin;
	}
	
	/**
	 * On reflection I realized you could just push smoothstone into an unedited chunk layer and increase overall drops
	 * for a world. So to counter-balance, on each extension we track the location of the blocks and increment their Y
	 * counters.
	 * 
	 * @param event the piston event
	 */
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void onPistonExtend(BlockPistonExtendEvent event) {
		Block source = event.getBlock();
		debug("Piston event from {0}", source.getLocation());
		Block extension = event.getBlock().getRelative(event.getDirection());
		for (Block b : event.getBlocks()) {
			Block next = b.getRelative(event.getDirection());
			if (next.equals(source) || next.equals(extension)) {
				continue;
			}
			plugin.getTracking().trackBreak(next.getLocation());
		}
		plugin.getTracking().trackBreak(source.getLocation());
		if (!source.equals(extension)) {
			plugin.getTracking().trackBreak(extension.getLocation());
		}
	}

	/**
	 * Should cover even more clever implementations involving sticky pistons to game things.
	 * 
	 * @param event the piston retract event
	 */
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void onPistonRetract(BlockPistonRetractEvent event) {
		if (!event.isSticky()) return; // only care about stick business.

		Block source = event.getBlock();
		debug("Sticky Piston event from {0}", source.getLocation());
		Block extension = event.getBlock().getRelative(event.getDirection());
		for (Block b : event.getBlocks()) {
			Block next = b.getRelative(event.getDirection());
			if (next.equals(source) || next.equals(extension)) {
				continue;
			}
			plugin.getTracking().trackBreak(next.getLocation());
		}
		plugin.getTracking().trackBreak(source.getLocation());
		if (!source.equals(extension)) {
			plugin.getTracking().trackBreak(extension.getLocation());
		}
	}

	/**
	 * Catch block placement directly.
	 * 
	 * @param event block place event
	 */
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void onPlacingThings(BlockPlaceEvent event) {
		Location placed = event.getBlockPlaced().getLocation();
		if (event.getPlayer() != null) {
			debug("Block place event at {0} by {1}", placed, event.getPlayer().getDisplayName());
		} else {
			debug("Block place event at {0}", placed);
		}

		plugin.getTracking().trackBreak(placed);
	}

	/**
	 * Catch explosions
	 * 
	 * TODO Issue#20: Support mining via TNT?
	 * 
	 * @param event explode event
	 */
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void onExplodingThings(BlockExplodeEvent event) {
		plugin.getTracking().trackBreak(event.getBlock().getLocation());
		debug("Explosion event at {0}", event.getBlock().getLocation());
		for (Block b : event.blockList()) {
			if (b != null) {
				plugin.getTracking().trackBreak(b.getLocation());
			}
		}
	}

	/**
	 * Prevent gaming by dropping sand/gravel/gravity blocks
	 * 
	 * @param event Change Block event
	 */
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void onFallingThings(EntityChangeBlockEvent event) {
		Material from = event.getBlock().getType();
		if (!event.getBlock().isEmpty() && !event.getBlock().isLiquid()) {
			if (!from.hasGravity()) return;
			if (!from.isBlock()) return;
			// At this point we've confirmed that the FROM used to be a block, that is now falling.
			debug("Block about to fall from {0}, was a {1}", event.getBlock().getLocation(), from);
		} else {
			// if (event.getBlock().isEmpty() || event.getBlock().isLiquid()) {
			// At this point we've confirmed that the FROM is air or liquid e.g. this is a block
			// that is done falling and wants to be a block again.
			if (EntityType.FALLING_BLOCK != event.getEntityType()) return;
			debug("Block has fallen to {0}, was a {1}", event.getBlock().getLocation(), from);
		}
		// track a break at FROM and TO, so you can't game sand/gravel by dropping it into a chunk.
		plugin.getTracking().trackBreak(event.getBlock().getLocation());
	}
	
	/**
	 * Prevent gaming using water/lava generators.
	 * 
	 * Add other generators as you become aware.
	 * 
	 * Credit for basic generator detector to fireblast709 (https://bukkit.org/threads/blocking-cobblestone-generators.120924/)
	 * 
	 * @param event block from to event
	 */
	@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
	public void onGeneratingThings(BlockFromToEvent event) {
		Block root = event.getBlock();
		Block block = event.getToBlock();
		Material type = root.getType();
		if (!Material.WATER.equals(type) && !Material.LAVA.equals(type)) {
			return; // not cobblegen.
		}
		Material mirror = Material.WATER.equals(type) ? Material.LAVA : Material.WATER;
		// Looks like 1.13 simplified this a lot, since flowing and stationary are now just "water", with state of flow represented in
		// a "Levelled" cast from BlockData of that block. Good job, Spigot/Bukkit -- much better imho.
		for (BlockFace face : faces) {
			Block check = block.getRelative(face, 1);
			Block check2 = root.getRelative(face, 1);
			if (mirror.equals(check.getType()) || mirror.equals(check2.getType())) {
				plugin.getTracking().trackBreak(block.getLocation());
				plugin.getTracking().trackBreak(check.getLocation());
				plugin.getTracking().trackBreak(check2.getLocation());
				debug("Generating something at union of {0} and {1}/{2}", block, check, check2);
				return;
			}
		}
	}
	
	private final BlockFace[] faces = new BlockFace[]
			{
				BlockFace.SELF,
				BlockFace.UP,
				BlockFace.DOWN,
				BlockFace.NORTH,
				BlockFace.EAST,
				BlockFace.SOUTH,
				BlockFace.WEST,
			};

	private void debug(String message, Object...replace) {
		if (Config.isDebug) {
			plugin.getLogger().log(Level.INFO, message, replace);
		}
	}
}
